":"; exec ./lokke -i "$0"  # -*-clojure-*-

;;; Copyright (C) 2019 Rob Browning <rlb@defaultvalue.org>
;;;
;;; This project is free software; you can redistribute it and/or
;;; modify it under the terms of (at your option) either of the
;;; following two licences:
;;;
;;;   1) The GNU Lesser General Public License as published by the
;;;      Free Software Foundation; either version 2.1, or (at your
;;;      option) any later version
;;;
;;;   2) The Eclipse Public License; either version 1.0 or (at your
;;;      option) any later version.

(ns test.clojure-exceptions
  (:require
   [clojure.test :refer [begin-tests end-tests is testing]]
   [lokke.exception :refer [ex-suppressed ex-tag]]))

;; The tests for this namespace are split between here and
;; test/lokke-exception.

(begin-tests (ns-name *ns*))

(is (= :yep (try :yep)))

(is (= :yep (try :yep (catch ExceptionInfo ex :nope))))

(is (= :nope (try (throw (ex-info "yep" {:kind 1}))
                  (catch ExceptionInfo ex :nope))))

(is (= nil (try)))
(is (= 1 (try 1)))
(is (= 3 (try 1 2 3)))

(defn same-ex-excepting-suppressed? [ex1 ex2]
  ;; Are they the same excepting the suppressed vector?
  (when (and (seq ex1) (seq ex2))
    (if (and (= ExceptionInfo (ex-tag ex1)) (= ExceptionInfo (ex-tag ex2)))
      (and (= (ex-message ex1) (ex-message ex2))
           (= (ex-data ex1) (ex-data ex2))
           (= (ex-cause ex1) (ex-cause ex2)))
      (= (seq ex1) (seq ex2)))))

(testing "finally behavior"
  (is (= nil (try (finally))))
  (is (= 1 (try 1 (finally))))
  (let [fin (atom [])]
    (is (= nil (try
                 (finally
                   (swap! fin conj 1)))))
    (is (= [1] (deref fin))))
  (let [fin (atom [])]
    (is (= nil (try
                 (finally
                   (swap! fin conj 1)
                   (swap! fin conj 2)))))
    (is (= [1 2] (deref fin))))
  (let [fin (atom [])]
    (is (= 1 (try
               (inc 0)
               (finally
                 (swap! fin conj 1)))))
    (is (= [1] (deref fin))))
  (let [fin (atom [])
        ex-1 (ex-info "one" {})]
    (try
      (try
        (throw ex-1)
        (finally
          (swap! fin conj 1)))
      (catch ExceptionInfo ex
        (is (same-ex-excepting-suppressed? ex-1 ex))))
    (is (= [1] (deref fin))))
  (let [fin (atom [])
        ex-1 (ex-info "one" {})
        ex-2 (ex-info "two" {})]
    (try
      (try
        (throw ex-1)
        (finally
          (swap! fin conj 1)
          (throw ex-2)))
      (catch ExceptionInfo ex
        (is (same-ex-excepting-suppressed? ex-1 ex))
        (is (= [ex-2] (seq (ex-suppressed ex))))))
    (is (= [1] (deref fin)))))

;; We can't easily test with-open here until we have some way to
;; create custom close methods.  See test/lokke-exception instead.

(end-tests (ns-name *ns*) :exit? true)
