#!./lokke -0 ;; -*-clojure-*-
!#

;;; Copyright (C) 2019-2020 Rob Browning <rlb@defaultvalue.org>
;;; SPDX-License-Identifier: LGPL-2.1-or-later OR EPL-1.0+

(ns test.clojure-exceptions
  (:require
   [clojure.test :refer [begin-tests end-tests is testing]]
   [lokke.exception :refer [ex-suppressed ex-tag]]))

;; The tests for this namespace are split between here and
;; test/lokke-exception.

(begin-tests (ns-name *ns*))

(is (= nil (try)))
(is (= 1 (try 1)))
(is (= 3 (try 1 2 3)))
(is (= :yep (try :yep)))
(is (= :yep (try :yep (finally true))))
(is (= :yep (try :yep (catch ExceptionInfo ex :nope))))
(is (= nil (try (finally true))))
(is (= nil (try (catch ExceptionInfo ex :nope))))
(is (= :nope (try (throw (ex-info "yep" {:kind 1}))
                  (catch ExceptionInfo ex :nope))))
(is (= :nope (try (throw (ex-info "yep" {:kind 1}))
                  (catch ExceptionInfo ex :nope))))
(is (= :nope (try (throw (ex-info "yep" {:kind 1}))
                  (catch ExceptionInfo ex :nope)
                  (finally true))))
(is (= :yep (try (inc "x") (catch 'wrong-type-arg ex :yep))))
(is (= :yep (try (inc "x") (catch Error ex :yep))))
(is (= :yep (try (throw (ex-info "yep" {:kind 1})) (catch Exception ex :yep))))
(is (= :yep (try (throw (ex-info "yep" {:kind 1})) (catch Throwable ex :yep))))

(testing "fall through"
  (is (= :yep
         (try
           (try (inc "x") (catch ExceptionInfo ex :nope))
           (catch Error ex :yep)))))

(testing "only one handler at a given level applies"
  (is (= :yep
         (try
           (try
             (throw (ex-info "yep" {:kind 1}))
             (catch ExceptionInfo ex (throw ex))
             (catch Throwable ex :nope))
           (catch ExceptionInfo ex :yep)))))

(defn same-ex-excepting-suppressed? [ex1 ex2]
  ;; Are they the same excepting the suppressed vector?
  (when (and (seq ex1) (seq ex2))
    (if (and (= ExceptionInfo (ex-tag ex1)) (= ExceptionInfo (ex-tag ex2)))
      (and (= (ex-message ex1) (ex-message ex2))
           (= (ex-data ex1) (ex-data ex2))
           (= (ex-cause ex1) (ex-cause ex2)))
      (= (seq ex1) (seq ex2)))))

(testing "finally behavior"
  (is (= nil (try (finally))))
  (is (= 1 (try 1 (finally))))
  (let [fin (atom [])]
    (is (= nil (try
                 (finally
                   (swap! fin conj 1)))))
    (is (= [1] (deref fin))))
  (let [fin (atom [])]
    (is (= nil (try
                 (finally
                   (swap! fin conj 1)
                   (swap! fin conj 2)))))
    (is (= [1 2] (deref fin))))
  (let [fin (atom [])]
    (is (= 1 (try
               (inc 0)
               (finally
                 (swap! fin conj 1)))))
    (is (= [1] (deref fin))))
  (let [fin (atom [])
        ex-1 (ex-info "one" {})]
    (try
      (try
        (throw ex-1)
        (finally
          (swap! fin conj 1)))
      (catch ExceptionInfo ex
        (is (same-ex-excepting-suppressed? ex-1 ex))))
    (is (= [1] (deref fin))))
  (let [fin (atom [])
        ex-1 (ex-info "one" {})
        ex-2 (ex-info "two" {})]
    (try
      (try
        (throw ex-1)
        (finally
          (swap! fin conj 1)
          (throw ex-2)))
      (catch ExceptionInfo ex
        (is (same-ex-excepting-suppressed? ex-1 ex))
        (is (= [ex-2] (seq (ex-suppressed ex))))))
    (is (= [1] (deref fin)))))

;; We can't easily test with-open here until we have some way to
;; create custom close methods.  See test/lokke-exception instead.

(end-tests (ns-name *ns*) :exit? true)
