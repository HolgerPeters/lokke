":"; exec ./lokke -i "$0"  # -*-clojure-*-

;;; Copyright (C) 2019 Ryan Senior <senior.ryan@gmail.com>
;;;
;;; This project is free software; you can redistribute it and/or
;;; modify it under the terms of (at your option) either of the
;;; following two licences:
;;;
;;;   1) The GNU Lesser General Public License as published by the
;;;      Free Software Foundation; either version 2.1, or (at your
;;;      option) any later version
;;;
;;;   2) The Eclipse Public License; either version 1.0 or (at your
;;;      option) any later version.

(ns test.clojure-collection
  (:require
   [clojure.test :refer [begin-tests end-tests is testing]]))

(begin-tests (ns-name *ns*))

(testing "rest behavior"
  (is (= '(2) (rest (list 1 2))))
  (is (= () (rest (list 1))))
  (is (= [2] (rest [1 2])))
  (is (= (list 2) (rest [1 2])))
  (is (= '(2) (rest [1 2])))
  (is (= [2] (rest (list 1 2))))
  (is (= (list 2) (rest (list 1 2))))
  (is (= '(2) (rest (list 1 2))))
  (is (empty? (rest [1])))
  (is (= (list) (rest [1])))
  (is (= () (rest [1]))))

(testing "empty list/vector tests"
  (is (= () ()))
  (is (= [] []))
  (is (= () []))
  (is (empty? ()))
  (is (empty? (seq ())))
  (is (empty? []))
  (is (empty? (seq [])))
  (is (not= () false))
  (is (not= '(1) true))
  (is (not= () nil))

  (is (not (empty? '(1))))
  (is (not (empty? [1]))))

(testing "vector tests"
  (is (not (= [1 2 3] #{4 5})))
  (is (not (= [1 2 3] (list 4 5))))
  (is (not (= [1 2 3] '(4 5)))))

(testing "full sequential equals"
  (is (not (= '(1 2 3) '(4 5 6))))
  (is (not (= (seq [1 2 3]) [4 5 6]))))

(testing "counted?"
  (is (not (counted? nil)))
  (is (counted? ()))
  ;; FIXME: These differ from clojure/jvm right now because '(...) is
  ;; actually just a guile pair.  Still have to decide if that's OK,
  ;; but this begins to suggest more strongly it might not be, i.e. we
  ;; may need a real persistent list sooner rather than later.
  (is (not (counted? '(1 2))))
  (is (not (counted? '(cons 1 (cons 2 nil))))))

(testing "bounded-count"
  (is (= 0 (bounded-count 0 ())))
  (is (= 0 (bounded-count 1 ())))
  (is (= 0 (bounded-count 0 '(1 2))))
  (is (= 1 (bounded-count 1 '(1 2))))
  (is (= 2 (bounded-count 2 '(1 2))))
  (is (= 2 (bounded-count 3 '(1 2))))

  (is (= 0 (bounded-count 0 [])))
  (is (= 0 (bounded-count 1 [])))
  (is (= 2 (bounded-count 0 [1 2])))
  (is (= 2 (bounded-count 1 [1 2])))
  (is (= 2 (bounded-count 2 [1 2])))
  (is (= 2 (bounded-count 3 [1 2]))))

(testing "reduce"
  (is (= 0 (reduce + [])))
  (is (= :fine (reduce (fn [] :crash) [:fine])))
  (is (= 3 (reduce + [1 2])))
  (is (= 6 (reduce + [1 2 3])))
  (is (= :default (reduce + :default [])))
  (is (= 6 (reduce + 1 [2 3]))))

(testing "filterv"
  (is (= [] (filterv identity ())))
  (is (= [1] (filterv identity '(1))))
  (is (= [1 3] (filterv odd? '(1 2 3 4)))))

(testing "mapv"
  (is (= [] (mapv identity ())))
  (is (= [1] (mapv identity '(1))))
  (is (= [2] (mapv inc '(1))))
  (is (= [2 3] (mapv inc '(1 2))))
  (is (= [4 6] (mapv + '(1 2) '(3 4)))))

(testing "get"
  (is (= nil (get {} 1)))
  (is (= :something (get {} 1 :something)))
  (is (= nil (get nil 1)))
  (is (= :something (get nil 1 :something)))
  (is (= 2 (get {1 2} 1)))
  (is (= nil (get {1 2} 3)))
  (is (= :something (get {1 2} 3 :something))))

(testing "take-while"
  (is (= nil (get {} 1)))
  (is (= :something (get {} 1 :something)))
  (is (= nil (get nil 1)))
  (is (= :something (get nil 1 :something)))
  (is (= 2 (get {1 2} 1)))
  (is (= nil (get {1 2} 3)))
  (is (= :something (get {1 2} 3 :something))))

(testing "iterate"
  (is (= [0 1 2] (take 3 (iterate inc 0)))))

(end-tests (ns-name *ns*) :exit? true)
